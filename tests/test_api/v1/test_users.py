import pytest
from httpx import AsyncClient
import uuid
from datetime import datetime, timezone

# Import User table for model interaction
# engine and text are no longer needed directly in this test file
from app.models import User
from sqlalchemy import insert
from sqlalchemy.engine import Connection # For type hinting the fixture

# Mark all tests in this module as async
pytestmark = pytest.mark.asyncio

API_PREFIX = "/api/v1"

async def test_list_users_empty(test_client: AsyncClient):
    """Test GET /users returns HTML with no users message when empty."""
    response = await test_client.get(f"{API_PREFIX}/users")

    assert response.status_code == 200
    assert "text/html" in response.headers["content-type"]
    # Check for specific content indicating emptiness and a link
    assert "No users found" in response.text

    # Check that the link generated by url_for contains the correct path
    # Get base_url dynamically from the test client
    base_url = str(test_client.base_url).rstrip('/')
    expected_url = f"{base_url}{API_PREFIX}/users"
    assert f'href="{expected_url}"' in response.text

    assert "<html>" in response.text # Basic structure check


# Use the db_conn fixture
async def test_list_users_one_user(test_client: AsyncClient, db_conn: Connection):
    """Test GET /users returns HTML listing one user when one exists."""
    test_user_id = f"user_{uuid.uuid4()}"
    test_username = f"test-user-{uuid.uuid4()}"
    test_user_data = {
        "_id": test_user_id,
        "username": test_username,
        "is_online": False,
    }

    # --- Setup: Insert user using the fixture's connection ---
    stmt = insert(User).values(test_user_data)
    db_conn.execute(stmt)
    # No commit needed now - API uses same transaction via dependency override

    # --- Action: Call the API endpoint ---
    response = await test_client.get(f"{API_PREFIX}/users")

    # --- Assertions ---
    assert response.status_code == 200
    assert "text/html" in response.headers["content-type"]
    assert test_username in response.text
    assert "No users found" not in response.text
    assert "<html>" in response.text

    # --- Cleanup: Handled automatically by the fixture's rollback ---


# Use the db_conn fixture
async def test_list_users_multiple_users(test_client: AsyncClient, db_conn: Connection):
    """Test GET /users returns HTML listing multiple users when they exist."""
    user1_id = f"user_{uuid.uuid4()}"
    user1_username = f"test-user-one-{uuid.uuid4()}"
    user1_data = {"_id": user1_id, "username": user1_username, "is_online": False}

    user2_id = f"user_{uuid.uuid4()}"
    user2_username = f"test-user-two-{uuid.uuid4()}"
    user2_data = {"_id": user2_id, "username": user2_username, "is_online": True}

    users_data = [user1_data, user2_data]

    # --- Setup: Insert users using the fixture's connection ---
    db_conn.execute(insert(User), users_data) # Use core executemany syntax
    # No commit needed now - API uses same transaction via dependency override

    # --- Action: Call the API endpoint ---
    response = await test_client.get(f"{API_PREFIX}/users")

    # --- Assertions ---
    assert response.status_code == 200
    assert "text/html" in response.headers["content-type"]
    assert user1_username in response.text
    assert user2_username in response.text
    assert "No users found" not in response.text
    assert "<html>" in response.text # Basic structure check

    # --- Cleanup: Handled automatically by the fixture's rollback --- 