import pytest
from httpx import AsyncClient
import uuid
from datetime import datetime, timezone

# Import DB engine and User table for direct interaction
from app.db import engine
from app.models import User
from sqlalchemy import insert, text

# Mark all tests in this module as async
pytestmark = pytest.mark.asyncio

API_PREFIX = "/api/v1"


async def test_list_users_empty(test_client: AsyncClient):
    """Test GET /users returns HTML with no users message when empty."""
    response = await test_client.get(f"{API_PREFIX}/users")

    assert response.status_code == 200
    assert "text/html" in response.headers["content-type"]
    # Check for specific content indicating emptiness and a link
    assert "No users found" in response.text

    # Check that the link generated by url_for contains the correct path
    # Get base_url dynamically from the test client
    base_url = str(test_client.base_url).rstrip('/')
    expected_url = f"{base_url}{API_PREFIX}/users"
    assert f'href="{expected_url}"' in response.text

    assert "<html>" in response.text # Basic structure check


async def test_list_users_one_user(test_client: AsyncClient):
    """Test GET /users returns HTML listing one user when one exists."""
    test_user_id = f"user_{uuid.uuid4()}"
    test_username = f"test-user-{uuid.uuid4()}"
    test_user_data = {
        "_id": test_user_id,
        "username": test_username,
        "is_online": False,
        # created_at/updated_at use server default in model
    }

    # --- Setup: Insert user directly into test DB ---
    # NOTE: Using synchronous engine connection within the async test function.
    # This is generally okay for simple setup/teardown in tests,
    # but for complex interactions or testing async db drivers,
    # you'd use an async engine/session (e.g., databases library, asyncpg).
    with engine.connect() as connection:
        transaction = connection.begin()
        try:
            # Clear any existing users first for isolation (optional, but safer)
            # Using text() for delete as table.delete() can be complex with ORMs sometimes
            # Commenting out delete for now, rely on cleanup below and session isolation
            # connection.execute(text(f"DELETE FROM {User.name}"))

            # Insert the test user
            stmt = insert(User).values(test_user_data)
            connection.execute(stmt)
            transaction.commit() # Commit insert before making API call
        except Exception:
            transaction.rollback() # Rollback on error during setup
            raise

    try:
        # --- Action: Call the API endpoint ---
        response = await test_client.get(f"{API_PREFIX}/users")

        # --- Assertions ---
        assert response.status_code == 200
        assert "text/html" in response.headers["content-type"]
        # Check for the user's username in the response
        assert test_username in response.text
        # Check that the "empty" message is NOT present
        assert "No users found" not in response.text
        assert "<html>" in response.text # Basic structure check

    finally:
        # --- Cleanup: Ensure user is removed ---
        # Re-opening connection and transaction for cleanup
        with engine.connect() as connection:
            transaction = connection.begin()
            try:
                 # Simple delete based on ID
                connection.execute(text(f"DELETE FROM {User.name} WHERE _id = :id"), {"id": test_user_id})
                transaction.commit()
            except Exception:
                transaction.rollback()
                # Log or handle cleanup error if necessary, but don't fail test here
                print(f"Warning: Cleanup failed for user {test_user_id}") 