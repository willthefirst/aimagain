# Pact provider testing example: POST /conversations (Ultra-thin layer approach)

This document demonstrates how to implement provider contract tests using our "ultra-thin layer" approach.

## Core goals

1.  **Contract Verification:** Ensure the provider (backend API) correctly understands and fulfills the contract defined by the consumer (e.g., frontend) for the `POST /conversations` interaction. This primarily involves validating the request structure (path, method, headers, body format) and ensuring the response structure matches the agreed-upon format for success.
2.  **Minimal Coupling:** The Pact provider test itself should be decoupled from the specific implementation details of the underlying business logic (e.g., database interactions, complex validation rules, interactions with other services).
3.  **Fast Feedback:** Pact tests should run quickly without needing external dependencies like databases or other microservices, providing rapid feedback on contract alignment.

## Reasoning for the "ultra-thin layer" approach

Directly testing API frameworks' route handlers (like those generated by `fastapi-users` or complex custom handlers) with Pact can sometimes require mocking multiple internal dependencies, potentially coupling the Pact test to the framework's or service's implementation details.

The "ultra-thin layer" approach addresses this by introducing:

1.  **An extremely thin API route handler:** Its _only_ responsibilities are:
    - Define the route (`POST /conversations`).
    - Leverage the web framework's capabilities for basic request body validation against a schema (e.g., Pydantic model `ConversationCreateRequest`). FastAPI does this automatically.
    - Depend on _one single_ injectable function/callable representing the entire next step of business logic execution (e.g., `handle_conversation_creation`).
    - Call this single dependency, passing the validated request data.
    - Return the result from the dependency.
2.  **A separate logic/handler layer:** This layer contains the actual business logic, including:
    - Handling authentication/authorization.
    - Performing detailed validation (e.g., UUID formats, business rules).
    - Interacting with services (e.g., `ConversationService`).
    - Handling errors from underlying services.

**Benefits:**

- **Simplified Pact Mocking:** The Pact provider test only needs to mock the single `handle_conversation_creation` dependency. The mock just needs to return a pre-defined successful response structure matching the contract.
- **Clear Boundary:** Creates a very clear separation between the API contract interface verification (Pact test) and the business logic implementation (tested by functional/integration tests).
- **Focus:** The Pact test focuses purely on whether the API layer correctly parses the request according to the schema and routes it to the next step.

**Trade-offs:**

- **Extra Layer:** Introduces an additional layer (`routes` + `logic`) in the production codebase.
- **Delegation Test:** Requires a separate functional test to ensure the thin route handler correctly calls the logic handler (`handle_conversation_creation`) with the right arguments.

## Code implementation

### 1. Ultra-thin route handler (`app/api/routes/conversation_routes.py`)

```python
# app/api/routes/conversation_routes.py
import logging
from fastapi import APIRouter, Depends, status, Request

from app.schemas.conversation import ConversationCreateRequest, ConversationResponse
# Import the handler dependency
from app.logic.conversation_processing import handle_conversation_creation

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post(
    "/conversations",
    response_model=ConversationResponse, # Defines final expected output structure
    status_code=status.HTTP_201_CREATED,
    tags=["conversations"],
)
async def conversation_request_handler(
    # 1. FastAPI validates request body against this Pydantic model.
    request_data: ConversationCreateRequest,

    # 2. Depend ONLY on the next processing step function/callable.
    handler = Depends(handle_conversation_creation),

    # 3. Pass the raw request if needed by the handler (e.g., for auth headers)
    request: Request
):
    """
    Ultra-thin route handler. Relies on FastAPI for request validation
    and delegates all processing to the injected 'handler'.
    """
    logger.debug("Conversation request handler invoked.")
    # Call the handler, passing validated data and request object
    result = await handler(request_data=request_data, request=request)
    logger.debug("Conversation request handler returning result from handler.")
    return result
```

### 2. Logic/handling layer (`app/logic/conversation_processing.py`)

```python
# app/logic/conversation_processing.py
import logging
from uuid import UUID
from fastapi import Depends, HTTPException, status, Request

from app.models import User
from app.schemas.conversation import ConversationCreateRequest, ConversationResponse
# Dependencies needed for the actual work are imported and used here
from app.auth_config import current_active_user
from app.services.conversation_service import (
    get_conversation_service, ConversationService,
    UserNotFoundError, # etc... import errors and handler
    handle_service_error,
)

logger = logging.getLogger(__name__)

async def handle_conversation_creation(
    # Gets data from the thin route handler
    request_data: ConversationCreateRequest,
    request: Request, # Needed for auth dependency
    # Gets dependencies via FastAPI's injector
    user: User = Depends(current_active_user),
    conv_service: ConversationService = Depends(get_conversation_service),
) -> ConversationResponse: # Must return the expected final structure
    """
    Handles the actual processing delegated from the route handler.
    Includes authorization, validation, service calls, error handling.
    """
    logger.debug(f"Handling conversation creation for user {user.id}")
    try:
        # UUID validation happens here
        try:
            invitee_uuid = UUID(request_data.invitee_user_id)
        except ValueError:
             raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid invitee user ID format.",
            )

        # Call the actual service
        new_conversation = await conv_service.create_new_conversation(
            creator_user=user,
            invitee_user_id=invitee_uuid,
            initial_message_content=request_data.initial_message,
        )

        # FastAPI handles ORM->Pydantic conversion based on endpoint's response_model
        logger.debug(f"Successfully handled conversation {new_conversation.id}")
        return new_conversation

    # Handle errors originating from the service or validation
    except Exception as e:
        logger.error(f"Error during conversation handling: {e}", exc_info=True)
        # Reuse or adapt error handling logic
        handle_service_error(e) # This might raise HTTPException
        # If handle_service_error doesn't raise, ensure we raise something
        raise HTTPException(status.HTTP_500_INTERNAL_SERVER_ERROR, "Handling failed")
```

### 3. provider contract test (`tests/contract/test_conversation_routes_provider.py`)

```python
# tests/contract/test_conversation_routes_provider.py
import pytest
import os
from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4
import logging

from fastapi import FastAPI
from pact import Verifier

from app.main import app # Assuming app includes conversation_routes.router
# Import the single dependency to mock from the route handler
from app.logic.conversation_processing import handle_conversation_creation
# Import the final response schema for structuring the mock's return value
from app.schemas.conversation import ConversationResponse

# --- Pact configuration ---
PROVIDER_NAME = "backend-api"
PACT_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "pacts")
PACT_FILE_CONVERSATIONS = os.path.join(PACT_DIR, "frontend-pact-conversations-backend-api.json") # Example name
logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)
# --- configuration end ---

@pytest.fixture(scope="module")
def app_override_conversation_routes():
    """Overrides the conversation handler dependency."""
    log.info("Setting up FastAPI app with override for Conversation Handler Pact")

    # 1. Define the successful return data structure (matching ConversationResponse)
    #    This should match the 'will_respond_with' body in your Pact file.
    dummy_response_data = {
        "id": str(uuid4()), # Example, or use 'Like' from pact
        "slug": "test-conversation-slug", # Example
        "created_by_user_id": str(uuid4()), # Example
        "name": None,
        "last_activity_at": None,
        "created_at": "2023-10-27T10:00:00Z", # Example
        "updated_at": "2023-10-27T10:00:00Z", # Example
        "participants": [
             {"user_id": str(uuid4()), "role": "creator"},
             {"user_id": str(uuid4()), "role": "participant"}
        ],
        "last_message": None
    }
    mock_handler_return_value = ConversationResponse(**dummy_response_data)

    # 2. Create the AsyncMock for the handler function
    mock_handler = AsyncMock(return_value=mock_handler_return_value)

    # 3. Override the single dependency used by the route handler
    original_overrides = app.dependency_overrides.copy()
    app.dependency_overrides[handle_conversation_creation] = lambda: mock_handler

    yield app # Provide the modified app

    # 4. Cleanup
    log.info("Cleaning up FastAPI app override for Conversation Handler")
    app.dependency_overrides = original_overrides


# --- provider state setup --- (likely minimal or no-op)
def provider_state_setup_conversation_routes(state: str, **params):
    log.info(f"Setting up provider state for Conversation Routes: '{state}'")
    pass # Mock is configured in fixture


# --- Pact verification test ---
def test_pact_verification_conversation_routes(app_override_conversation_routes: FastAPI):
    """Verify the Conversation Routes Pact contract."""
    log.info(f"Starting Pact verification for '{PROVIDER_NAME}' conv routes using '{PACT_FILE_CONVERSATIONS}'")
    if not os.path.exists(PACT_FILE_CONVERSATIONS):
         pytest.fail(f"Pact file not found: {PACT_FILE_CONVERSATIONS}")

    verifier = Verifier(
        provider=PROVIDER_NAME,
        provider_base_url="http://localhost",
        provider_app=app_override_conversation_routes, # Use the fixture
        pact_source=PACT_FILE_CONVERSATIONS,
        provider_state_setup=provider_state_setup_conversation_routes,
    )

    log.info("Running Verifier for Conversation Routes...")
    success, logs_dict = verifier.verify()

    if success != 0:
        log.error("Conversation Routes Pact verification failed. Logs:")
        import json; print(json.dumps(logs_dict, indent=4))
    assert success == 0, f"Pact verification failed (exit code: {success})."

    log.info("Conversation Routes Pact verification successful!")
```

## Test responsibilities summary

- **Pact Consumer Test:** Defines the expected request/response interaction from the consumer's perspective and generates the Pact contract file. Mocks the provider.
- **Pact Provider Test (This file):** Verifies the provider's thin API route handler against the Pact contract file. Mocks the single `handle_conversation_creation` dependency. _Focus: Contract adherence of the API layer._
- **Functional Test (Handler Delegation):** Verifies that the `conversation_request_handler` correctly calls the `handle_conversation_creation` function with the expected arguments. Mocks `handle_conversation_creation`. _Focus: Integration between route layer and logic layer._
- **Functional/Integration Test (Logic Layer):** Verifies the complete business logic within `handle_conversation_creation`, including interactions with the real `ConversationService` and potentially a test database. _Focus: Correctness of the business logic._

This layered testing approach ensures that the API contract is explicitly verified while keeping the different testing concerns (contract vs. logic vs. integration) separated.
